import { n as __commonJS, r as __toESM, t as require_react } from "./react-DOLv65KA.js";

//#region node_modules/react-fast-compare/index.js
var require_react_fast_compare = /* @__PURE__ */ __commonJS({ "node_modules/react-fast-compare/index.js": ((exports, module) => {
	var hasElementType = typeof Element !== "undefined";
	var hasMap = typeof Map === "function";
	var hasSet = typeof Set === "function";
	var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
	function equal(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
				return true;
			}
			var it;
			if (hasMap && a instanceof Map && b instanceof Map) {
				if (a.size !== b.size) return false;
				it = a.entries();
				while (!(i = it.next()).done) if (!b.has(i.value[0])) return false;
				it = a.entries();
				while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false;
				return true;
			}
			if (hasSet && a instanceof Set && b instanceof Set) {
				if (a.size !== b.size) return false;
				it = a.entries();
				while (!(i = it.next()).done) if (!b.has(i.value[0])) return false;
				return true;
			}
			if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
				length = a.length;
				if (length != b.length) return false;
				for (i = length; i-- !== 0;) if (a[i] !== b[i]) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function") return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function") return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
			if (hasElementType && a instanceof Element) return false;
			for (i = length; i-- !== 0;) {
				if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) continue;
				if (!equal(a[keys[i]], b[keys[i]])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	}
	module.exports = function isEqual$2(a, b) {
		try {
			return equal(a, b);
		} catch (error) {
			if ((error.message || "").match(/stack|recursion/i)) {
				console.warn("react-fast-compare cannot handle circular refs");
				return false;
			}
			throw error;
		}
	};
}) });

//#endregion
//#region node_modules/react-snowfall/lib/utils.js
var import_react_fast_compare$1 = /* @__PURE__ */ __toESM(require_react_fast_compare(), 1);
/**
* Enhanced random function, selects a random value between a minimum and maximum. If the values provided are both
* integers then the number returned will be an integer, otherwise the return number will be a decimal.
* @param min The minimum value
* @param max The maximum value
*/
function random(min, max) {
	if (!Number.isInteger(min) || !Number.isInteger(max)) return Math.random() * (max - min) + min;
	else return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
* Linear interpolation function to gradually step towards a target value
* @param start The current value
* @param end The target value
* @param normal The rate of change between 0 and 1 (0 = no change, 1 = instant)
*/
function lerp(start, end, normal) {
	return (1 - normal) * start + normal * end;
}
/**
* Selects a random item from an array of inputs.
*
* @param items The array of items to choose from
* @returns A random item selected from the array
*/
function randomElement(items) {
	return items[Math.floor(Math.random() * items.length)];
}
/**
* Gets the height and width of the provided HTML element
* @param element The html element to measure
*/
function getSize(element) {
	if (!element) return {
		height: 0,
		width: 0
	};
	return {
		height: element.offsetHeight,
		width: element.offsetWidth
	};
}
/**
* Store the value of PI * 2.
*
* This is so we can avoid calculating this value every time we draw a circle.
*/
const twoPi = Math.PI * 2;

//#endregion
//#region node_modules/react-snowfall/lib/Snowflake.js
const defaultConfig = {
	color: "#dee4fd",
	radius: [.5, 3],
	speed: [1, 3],
	wind: [-.5, 2],
	changeFrequency: 200,
	rotationSpeed: [-1, 1],
	opacity: [1, 1],
	enable3DRotation: false
};
/**
* An individual snowflake that will update it's location every call to `update`
* and draw itself to the canvas every call to `draw`.
*/
var Snowflake = class Snowflake {
	/**
	* A utility function to create a collection of snowflakes
	* @param canvas The canvas element
	* @param amount The number of snowflakes
	* @param config The configuration for each snowflake
	*/
	static createSnowflakes(canvas, amount, config) {
		if (!canvas) return [];
		const snowflakes = [];
		for (let i = 0; i < amount; i++) snowflakes.push(new Snowflake(canvas, config));
		return snowflakes;
	}
	constructor(canvas, config = {}) {
		this.updateConfig(config);
		const { radius, wind, speed, rotationSpeed, opacity, enable3DRotation } = this.config;
		this.params = {
			x: random(0, canvas.offsetWidth),
			y: random(-canvas.offsetHeight, 0),
			rotation: random(0, 360),
			radius: random(...radius),
			speed: random(...speed),
			wind: random(...wind),
			rotationSpeed: random(...rotationSpeed),
			nextSpeed: random(...speed),
			nextWind: random(...wind),
			nextRotationSpeed: random(...rotationSpeed),
			opacity: random(...opacity),
			hasNextOpacity: false,
			rotationX: enable3DRotation ? random(0, 360) : 0,
			rotationY: enable3DRotation ? random(0, 360) : 0,
			rotationSpeedX: enable3DRotation ? random(-2, 2) : 0,
			rotationSpeedY: enable3DRotation ? random(-2, 2) : 0,
			nextRotationSpeedX: enable3DRotation ? random(-2, 2) : 0,
			nextRotationSpeedY: enable3DRotation ? random(-2, 2) : 0
		};
		this.framesSinceLastUpdate = 0;
	}
	selectImage() {
		if (this.config.images && this.config.images.length > 0) this.image = randomElement(this.config.images);
		else this.image = void 0;
	}
	updateConfig(config) {
		const previousConfig = this.config;
		this.config = {
			...defaultConfig,
			...config
		};
		this.config.changeFrequency = random(this.config.changeFrequency, this.config.changeFrequency * 1.5);
		if (this.params && !(0, import_react_fast_compare$1.default)(this.config.radius, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.radius)) this.params.radius = random(...this.config.radius);
		if (!(0, import_react_fast_compare$1.default)(this.config.images, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.images)) this.selectImage();
		if ((previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.opacity) && !(0, import_react_fast_compare$1.default)(this.config.opacity, previousConfig === null || previousConfig === void 0 ? void 0 : previousConfig.opacity)) this.params.hasNextOpacity = true;
	}
	updateTargetParams() {
		this.params.nextSpeed = random(...this.config.speed);
		this.params.nextWind = random(...this.config.wind);
		if (this.image) this.params.nextRotationSpeed = random(...this.config.rotationSpeed);
		if (this.config.enable3DRotation) {
			this.params.nextRotationSpeedX = random(-2, 2);
			this.params.nextRotationSpeedY = random(-2, 2);
		}
	}
	update(offsetWidth, offsetHeight, framesPassed = 1) {
		const { x, y, rotation, rotationSpeed, nextRotationSpeed, wind, speed, nextWind, nextSpeed, radius } = this.params;
		this.params.x = (x + wind * framesPassed) % (offsetWidth + radius * 2);
		if (this.params.x > offsetWidth + radius) this.params.x = -radius;
		this.params.y = (y + speed * framesPassed) % (offsetHeight + radius * 2);
		if (this.params.y > offsetHeight + radius) {
			if (this.params.hasNextOpacity) {
				this.params.opacity = random(...this.config.opacity);
				this.params.hasNextOpacity = false;
			}
			this.params.y = -radius;
		}
		if (this.image || this.config.enable3DRotation) this.params.rotation = (rotation + rotationSpeed) % 360;
		if (this.config.enable3DRotation) {
			this.params.rotationX = (this.params.rotationX + this.params.rotationSpeedX * framesPassed) % 360;
			this.params.rotationY = (this.params.rotationY + this.params.rotationSpeedY * framesPassed) % 360;
		}
		this.params.speed = lerp(speed, nextSpeed, .01);
		this.params.wind = lerp(wind, nextWind, .01);
		this.params.rotationSpeed = lerp(rotationSpeed, nextRotationSpeed, .01);
		if (this.config.enable3DRotation) {
			this.params.rotationSpeedX = lerp(this.params.rotationSpeedX, this.params.nextRotationSpeedX, .01);
			this.params.rotationSpeedY = lerp(this.params.rotationSpeedY, this.params.nextRotationSpeedY, .01);
		}
		if (this.framesSinceLastUpdate++ > this.config.changeFrequency) {
			this.updateTargetParams();
			this.framesSinceLastUpdate = 0;
		}
	}
	getImageOffscreenCanvas(image, size) {
		var _a, _b;
		if (image instanceof HTMLImageElement && image.loading) return image;
		let sizes = Snowflake.offscreenCanvases.get(image);
		if (!sizes) {
			sizes = {};
			Snowflake.offscreenCanvases.set(image, sizes);
		}
		if (!(size in sizes)) {
			const canvas = document.createElement("canvas");
			canvas.width = size;
			canvas.height = size;
			(_a = canvas.getContext("2d")) === null || _a === void 0 || _a.drawImage(image, 0, 0, size, size);
			sizes[size] = canvas;
		}
		return (_b = sizes[size]) !== null && _b !== void 0 ? _b : image;
	}
	/**
	* Applies 3D rotation transform to the canvas context.
	* This method calculates and applies the transformation matrix for 3D rotation effects.
	*
	* @param ctx The canvas context to apply the transform to
	* @param x The x position to translate to
	* @param y The y position to translate to
	*/
	apply3DTransform(ctx, x, y) {
		if (this.config.enable3DRotation) {
			const { rotationX, rotationY } = this.params;
			const rotation = this.params.rotation || 0;
			const radX = rotationX * Math.PI / 180;
			const radY = rotationY * Math.PI / 180;
			const radZ = rotation * Math.PI / 180;
			const cosX = Math.cos(radX);
			const sinX = Math.sin(radX);
			const cosY = Math.cos(radY);
			const sinY = Math.sin(radY);
			const cosZ = Math.cos(radZ);
			const sinZ = Math.sin(radZ);
			const a = cosZ * cosY;
			const b = cosZ * sinY * sinX - sinZ * cosX;
			const c = cosZ * sinY * cosX + sinZ * sinX;
			const d = sinZ * cosY;
			ctx.setTransform(a, b, c, d, x, y);
		} else {
			const radian = (this.params.rotation || 0) * Math.PI / 180;
			const cos = Math.cos(radian);
			const sin = Math.sin(radian);
			ctx.setTransform(cos, sin, -sin, cos, x, y);
		}
	}
	/**
	* Draws a circular snowflake to the canvas.
	*
	* This method should only be called if our config does not have images.
	*
	* This method assumes that a path has already been started on the canvas.
	* `ctx.beginPath()` should be called before calling this method.
	*
	* After calling this method, the fillStyle should be set to the snowflake's
	* color and `ctx.fill()` should be called to fill the snowflake.
	*
	* Calling `ctx.fill()` after multiple snowflakes have had `drawCircle` called
	* will render all of the snowflakes since the last call to `ctx.beginPath()`.
	*
	* @param ctx The canvas context to draw to
	*/
	drawCircle(ctx) {
		ctx.moveTo(this.params.x, this.params.y);
		ctx.arc(this.params.x, this.params.y, this.params.radius, 0, twoPi);
	}
	/**
	* Draws a circular snowflake with 3D rotation effect to the canvas.
	*
	* This method is used when 3D rotation is enabled and images are not being used.
	*
	* @param ctx The canvas context to draw to
	* @param color The color to fill the circle with
	*/
	drawCircle3D(ctx, color) {
		const { x, y, radius } = this.params;
		ctx.save();
		if (this.config.enable3DRotation) this.apply3DTransform(ctx, x, y);
		else ctx.translate(x, y);
		ctx.beginPath();
		ctx.arc(0, 0, radius, 0, twoPi);
		ctx.fillStyle = color;
		ctx.fill();
		ctx.restore();
	}
	/**
	* Draws an image-based snowflake to the canvas.
	*
	* This method should only be called if our config has images.
	*
	* @param ctx The canvas context to draw to
	*/
	drawImage(ctx) {
		const { x, y, radius } = this.params;
		ctx.save();
		if (this.params.opacity !== 1) ctx.globalAlpha = this.params.opacity;
		this.apply3DTransform(ctx, x, y);
		const image = this.getImageOffscreenCanvas(this.image, radius);
		ctx.drawImage(image, -(radius / 2), -(radius / 2), radius, radius);
		ctx.restore();
	}
};
Snowflake.offscreenCanvases = /* @__PURE__ */ new WeakMap();
var Snowflake_default = Snowflake;

//#endregion
//#region node_modules/react-snowfall/lib/config.js
const snowfallBaseStyle = {
	pointerEvents: "none",
	backgroundColor: "transparent",
	position: "absolute",
	top: 0,
	left: 0,
	width: "100%",
	height: "100%"
};
const targetFrameTime = 1e3 / 60;

//#endregion
//#region node_modules/react-snowfall/lib/SnowfallCanvas.js
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _SnowfallCanvas_ctx, _SnowfallCanvas_canvas;
var SnowfallCanvas = class {
	get ctx() {
		return __classPrivateFieldGet(this, _SnowfallCanvas_ctx, "f");
	}
	get canvas() {
		return __classPrivateFieldGet(this, _SnowfallCanvas_canvas, "f");
	}
	set canvas(canvas) {
		__classPrivateFieldSet(this, _SnowfallCanvas_canvas, canvas, "f");
		__classPrivateFieldSet(this, _SnowfallCanvas_ctx, canvas.getContext("2d"), "f");
	}
	constructor(canvas, config) {
		this.lastUpdate = Date.now();
		this.snowflakes = [];
		_SnowfallCanvas_ctx.set(this, void 0);
		_SnowfallCanvas_canvas.set(this, void 0);
		__classPrivateFieldSet(this, _SnowfallCanvas_canvas, canvas, "f");
		__classPrivateFieldSet(this, _SnowfallCanvas_ctx, canvas.getContext("2d"), "f");
		this.config = {
			snowflakeCount: 150,
			...defaultConfig,
			...config
		};
		this.snowflakes = [];
		this.snowflakes = Snowflake_default.createSnowflakes(canvas, config.snowflakeCount || 150, config);
		this.play();
	}
	/**
	* Updates the config used for the snowfall animation, if the number of snowflakes
	* has changed then this will create new or remove existing snowflakes gracefully
	* to retain the position of as many existing snowflakes as possible.
	*/
	updateConfig(config) {
		this.config = {
			...this.config,
			...config
		};
		const sizeDifference = this.config.snowflakeCount - this.snowflakes.length;
		if (sizeDifference > 0) this.snowflakes = [...this.snowflakes, ...Snowflake_default.createSnowflakes(this.canvas, sizeDifference, config)];
		if (sizeDifference < 0) this.snowflakes = this.snowflakes.slice(0, this.config.snowflakeCount);
		for (const snowflake of this.snowflakes) snowflake.updateConfig(this.config);
	}
	/**
	* Updates the location of each snowflake based on the number of frames passed then
	* clears the canvas and draws each snowflake.
	*/
	render(framesPassed = 1) {
		const { ctx, canvas, snowflakes } = this;
		if (!ctx || !canvas) return;
		const { offsetWidth, offsetHeight } = canvas;
		for (const snowflake of snowflakes) snowflake.update(offsetWidth, offsetHeight, framesPassed);
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, offsetWidth, offsetHeight);
		if (this.config.images && this.config.images.length > 0) {
			for (const snowflake of snowflakes) snowflake.drawImage(ctx);
			return;
		}
		if (this.config.enable3DRotation) for (const snowflake of snowflakes) snowflake.drawCircle3D(ctx, this.config.color);
		else {
			ctx.beginPath();
			for (const snowflake of snowflakes) snowflake.drawCircle(ctx);
			ctx.fillStyle = this.config.color;
			ctx.fill();
		}
	}
	/**
	* The animation loop, will calculate the time since the last render and update
	* the position of the snowflakes appropriately before queueing another frame.
	*/
	loop() {
		const now = Date.now();
		const msPassed = Date.now() - this.lastUpdate;
		this.lastUpdate = now;
		const framesPassed = msPassed / targetFrameTime;
		this.render(framesPassed);
		this.animationFrame = requestAnimationFrame(() => this.loop());
	}
	/** Start the animation playing. */
	play() {
		this.loop();
	}
	/** Pause the animation. */
	pause() {
		if (this.animationFrame) {
			cancelAnimationFrame(this.animationFrame);
			this.animationFrame = void 0;
		}
	}
};
_SnowfallCanvas_ctx = /* @__PURE__ */ new WeakMap(), _SnowfallCanvas_canvas = /* @__PURE__ */ new WeakMap();

//#endregion
//#region node_modules/react-snowfall/lib/hooks.js
var import_react = require_react();
var import_react_fast_compare = /* @__PURE__ */ __toESM(require_react_fast_compare(), 1);
/**
* Returns the height and width of a HTML element, uses the `ResizeObserver` api if available to detect changes to the
* size. Falls back to listening for resize events on the window.
* @param ref A ref to the HTML element to be measured
*/
const useComponentSize = (ref) => {
	const [size, setSize] = (0, import_react.useState)(getSize(ref.current));
	const resizeHandler = (0, import_react.useCallback)(() => {
		if (ref.current) setSize(getSize(ref.current));
	}, [ref]);
	(0, import_react.useEffect)(() => {
		const { ResizeObserver } = window;
		if (!ref.current) return;
		resizeHandler();
		if (typeof ResizeObserver === "function") {
			const resizeObserver = new ResizeObserver(resizeHandler);
			resizeObserver.observe(ref.current);
			return () => resizeObserver.disconnect();
		} else {
			window.addEventListener("resize", resizeHandler);
			return () => window.removeEventListener("resize", resizeHandler);
		}
	}, [ref, resizeHandler]);
	return size;
};
/**
* Utility hook that merges any provided styles with the default styles
* @param overrides The style prop passed into the component
*/
const useSnowfallStyle = (overrides) => {
	return (0, import_react.useMemo)(() => ({
		...snowfallBaseStyle,
		...overrides || {}
	}), [overrides]);
};
/**
* Same as `React.useEffect` but uses a deep comparison on the dependency array. This should only
* be used when working with non-primitive dependencies.
*
* @param effect Effect callback to run
* @param deps Effect dependencies
*/
function useDeepCompareEffect(effect, deps) {
	const ref = (0, import_react.useRef)(deps);
	if (!(0, import_react_fast_compare.default)(deps, ref.current)) ref.current = deps;
	return (0, import_react.useEffect)(effect, ref.current);
}
/**
* Utility hook to stabilize a reference to a value, the returned value will always match the input value
* but (unlike an inline object) will maintain [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
* equality until a change is made.
*
* @example
*
* const obj = useDeepMemo({ foo: 'bar', bar: 'baz' }) // <- inline object creation
* const prevValue = usePrevious(obj) // <- value from the previous render
* console.log(obj === prevValue) // <- always logs true until value changes
*/
function useDeepMemo(value) {
	const [state, setState] = (0, import_react.useState)(value);
	useDeepCompareEffect(() => setState(value), [value]);
	return state;
}

//#endregion
//#region node_modules/react-snowfall/lib/Snowfall.js
const Snowfall = ({ color = defaultConfig.color, changeFrequency = defaultConfig.changeFrequency, radius = defaultConfig.radius, speed = defaultConfig.speed, wind = defaultConfig.wind, rotationSpeed = defaultConfig.rotationSpeed, opacity = defaultConfig.opacity, snowflakeCount = 150, images, enable3DRotation = defaultConfig.enable3DRotation, style } = {}) => {
	const mergedStyle = useSnowfallStyle(style);
	const canvasRef = (0, import_react.useRef)(null);
	const canvasSize = useComponentSize(canvasRef);
	const config = useDeepMemo({
		color,
		changeFrequency,
		radius,
		speed,
		wind,
		rotationSpeed,
		images,
		snowflakeCount,
		opacity,
		enable3DRotation
	});
	const configRef = (0, import_react.useRef)(config);
	const snowfallCanvasRef = (0, import_react.useRef)();
	(0, import_react.useEffect)(() => {
		if (!snowfallCanvasRef.current && canvasRef.current) snowfallCanvasRef.current = new SnowfallCanvas(canvasRef.current, configRef.current);
		return () => {
			var _a;
			(_a = snowfallCanvasRef.current) === null || _a === void 0 || _a.pause();
			snowfallCanvasRef.current = void 0;
		};
	}, []);
	(0, import_react.useEffect)(() => {
		if (snowfallCanvasRef.current) snowfallCanvasRef.current.updateConfig(config);
	}, [config]);
	return import_react.createElement("canvas", {
		ref: canvasRef,
		height: canvasSize.height,
		width: canvasSize.width,
		style: mergedStyle,
		"data-testid": "SnowfallCanvas"
	});
};
var Snowfall_default = Snowfall;

//#endregion
export { Snowfall, SnowfallCanvas, Snowfall_default as default };
//# sourceMappingURL=react-snowfall.js.map